
hashMap
	初始化
		使用已有map初试化
			若tab为空，按照map初试化对应的大小
			如果tab不为空，先扩充2倍空间
			循环插入每个值
	putValue
		若当前tab为空--初始化16的tab数组
		有tab数组，当前位置为空，直接初始化node放入
		当前位置已经存在node节点
			链表--先查找是否有值，之后再插入
				若找到相同key，走下面的值替换的逻辑
				若没有找到，插入到链表的尾部
					判断下是否需要转换为红黑树--链表长度大于8(tab长度大于64，否则会进行扩容)
			红黑树--红黑树的节点插入
			对存在key，进行值替换
		修改modCount
		判断是否需要扩容
	getNode
		若tab不为空，且tab长度大于0，且当前tab存在值，进行查询，否则返回null
		如果第一个就为查询的key，返回当前节点
		遍历查询
			红黑树--查询
			链表--查找
	resize
		空间大小
			tab为空--默认大小16，因子0.75，阈值=16*0.75
			tab存在
				已经超过最大长度(2^30)--不再继续扩容，阈值修改为最大值2^31-1
				扩展2倍在最大长度内，扩展2倍空间
		数据维护
			遍历老tab中每个元数
				当前元数为空--直接跳过
				不为空
					如果只有一个元数，直接放入新tab中对应位置
					如果多个元数
						链表--
							遍历每个元数，判断属于当前位置还是当前位置+历史容量
							构建两个连边，放入对应的位置中
						红黑树--红黑树的切分操作
	removeNode
		首先查询到是否存在当前key，会记录相同key的node和前缀p
		判断node是否不为空
			黑红树删除
			若删除的元素和前缀一致(删除的是第一个存在元素)，将当前tab位置放入node.next
			若不是，则将p.next指向node.next

ArrayList

垃圾回收
	内存结构
		线程独有
			程序计数器--对计算机中程序计数器的抽象，标识当前线程执行方法顺序
			虚拟机栈--线程方法执行记录，存储单位为栈帧，优化栈顶寄存器缓存
				局部变量表
				操作数栈
				动态链接
				方法返回地址
				附加信息
			本地方法栈--本地方法使用，Hotspot当前和虚拟机栈混用
		线程共享
			堆--存放对象实例，垃圾回收区域
			方法区--静态变量、常量池、类元信息(元空间)
	内存模型
		当前cpu和内存间，一般会通过增加寄存器和高速缓存的方式协调cpu和内存速率问题，因此堆栈映射到物理机上，可能处于内存、缓存、寄存器中
	cms
		使用场景--老年代
		收集思路
			初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
			并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
			重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
			并发清除: 不需要停顿。
		问题
			吞吐量低，低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高
				与用户线程并行
				无内存整理，容易触发fullGc
			无法处理浮动垃圾--并发清除阶段用户线程产生的垃圾
			空间碎片--标记清除算法导致
	g1
		内存结构
			分区--将堆内存按照分区形式组织，默认分为2048个分区
			卡片--分区内部使用，512B
		数据结构
			已记忆集合--反向指针，记录引用分区内对象的卡片索引--老年代分区具有(年轻代每次扫描，无需该信息也可分区间引用关系)
			Per Region Table--已记忆集合用于记录应用情况
				稀少：直接记录引用对象的卡片索引
				细粒度：记录引用对象的分区索引
				粗粒度：只记录引用情况，每个分区对应一个比特位
		触发时机
			年轻代--分配到Eden失败
			老年代--老年代使用达到阈值比例(InitiatingHeapOccupancyPercent,默认45%)
				具体收集次数--
					G1MixedGCCountTarget--最大混合收集次数
					G1HeapWastePercent--废料比例，不超过可不启动混合回收
		标记方法
			三色标记法
				漏标问题：在标记过程中，自己被标记但成员变量没有标记，且成员变量的引用取消，转移到一个已经标记的对象上，会产生漏标
				漏标条件：已标记对象有新的引用；成员未标记对象有引用删除
				解决方式：记录未完全标记对象的引用删除
					记录标记完全对象，需要重新扫描，成本较高
					引用删除+已记忆集合，可快速效验删除对象是否还有效
		收集流程
			
		特点
		解决问题

多线程
	线程池

并发

doris

spark
	概述
		资源
	rdd
	宽窄依赖
		宽依赖：shuffle阶段
	阶段划分
		从后往前检测，若有宽依赖算子，则新增一个阶段

数组

链表

树

图

贪心

动态规划

回溯

LSM-Tree

spring
	aop
	di

springAi






