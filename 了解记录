
hashMap
	初始化
		使用已有map初试化
			若tab为空，按照map初试化对应的大小
			如果tab不为空，先扩充2倍空间
			循环插入每个值
	putValue
		若当前tab为空--初始化16的tab数组
		有tab数组，当前位置为空，直接初始化node放入
		当前位置已经存在node节点
			链表--先查找是否有值，之后再插入
				若找到相同key，走下面的值替换的逻辑
				若没有找到，插入到链表的尾部
					判断下是否需要转换为红黑树--链表长度大于8(tab长度大于64，否则会进行扩容)
			红黑树--红黑树的节点插入
			对存在key，进行值替换
		修改modCount
		判断是否需要扩容
	getNode
		若tab不为空，且tab长度大于0，且当前tab存在值，进行查询，否则返回null
		如果第一个就为查询的key，返回当前节点
		遍历查询
			红黑树--查询
			链表--查找
	resize
		空间大小
			tab为空--默认大小16，因子0.75，阈值=16*0.75
			tab存在
				已经超过最大长度(2^30)--不再继续扩容，阈值修改为最大值2^31-1
				扩展2倍在最大长度内，扩展2倍空间
		数据维护
			遍历老tab中每个元数
				当前元数为空--直接跳过
				不为空
					如果只有一个元数，直接放入新tab中对应位置
					如果多个元数
						链表--
							遍历每个元数，判断属于当前位置还是当前位置+历史容量
							构建两个连边，放入对应的位置中
						红黑树--红黑树的切分操作
	removeNode
		首先查询到是否存在当前key，会记录相同key的node和前缀p
		判断node是否不为空
			黑红树删除
			若删除的元素和前缀一致(删除的是第一个存在元素)，将当前tab位置放入node.next
			若不是，则将p.next指向node.next

ArrayList

垃圾回收

多线程

并发

doris

spark

数组

链表

树

图

贪心

动态规划

回溯

LSM-Tree

spring
	aop
	di





